package clickhouseanalyzer

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// ServiceEndpoints holds the service endpoints for a service
type ServiceEndpoints struct {
	ServiceName string
	Endpoints   []ServiceEndpoint
}

// Template for generating the Go file
const serviceEndpointsTemplate = `// Code generated by clickhouseanalyzer; DO NOT EDIT.
package serviceendpoints

// ServiceEndpoint represents a service endpoint from ClickHouse analysis
type ServiceEndpoint struct {
	ServiceName      string
	RequestMethod    string
	ResponseStatus   string
	Route            string
	ServerAddress    string
	ServerPort       string
}

// ServiceEndpoints maps service names to their endpoints
var ServiceEndpoints = map[string][]ServiceEndpoint{
{{- range .Services }}
	"{{ .ServiceName }}": {
		{{- range .Endpoints }}
		{
			ServiceName:    "{{ .ServiceName }}",
			RequestMethod:  "{{ .RequestMethod }}",
			ResponseStatus: "{{ .ResponseStatus }}",
			Route:          "{{ .Route }}",
			ServerAddress:  "{{ .ServerAddress }}",
			ServerPort:     "{{ .ServerPort }}",
		},
		{{- end }}
	},
{{- end }}
}

// GetEndpointsByService returns all endpoints for a service
func GetEndpointsByService(serviceName string) []ServiceEndpoint {
	if endpoints, exists := ServiceEndpoints[serviceName]; exists {
		return endpoints
	}
	return []ServiceEndpoint{}
}

// GetAllServices returns a list of all available service names
func GetAllServices() []string {
	services := make([]string, 0, len(ServiceEndpoints))
	for service := range ServiceEndpoints {
		services = append(services, service)
	}
	return services
}
`

// GenerateServiceEndpointsFile generates a Go file with service endpoints
func GenerateServiceEndpointsFile(endpoints []ServiceEndpoint, outputFilePath string) error {
	// Group endpoints by service
	serviceMap := make(map[string][]ServiceEndpoint)
	for _, endpoint := range endpoints {
		serviceMap[endpoint.ServiceName] = append(serviceMap[endpoint.ServiceName], endpoint)
	}

	// Transform to services slice
	var services []ServiceEndpoints
	for serviceName, serviceEndpoints := range serviceMap {
		services = append(services, ServiceEndpoints{
			ServiceName: serviceName,
			Endpoints:   serviceEndpoints,
		})
	}

	// Create template data
	templateData := struct {
		Services []ServiceEndpoints
	}{
		Services: services,
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFilePath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Parse template
	tmpl, err := template.New("serviceEndpointsTemplate").Parse(serviceEndpointsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Execute template
	if err := tmpl.Execute(outFile, templateData); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
